use std::ecdsa_secp256k1::verify_signature;
use std::hash::keccak256;

mod test;

/// Ethereum address
type Address = [u8; 20];

/// Ring Signature-like Verifier
///
/// Verifies that one of the Ethereum addresses in the array has signed a given
/// message hash.
///
/// > Note: If the number of addresses is less than the threshold, simply pad
/// > the array with zero-addresses.
///
/// ## Value Parameters
///
/// - `message_hash`: Hash digest of the group signature
/// - `members`: Ethereum address array containing members of the group and one signer
/// - `signer_pub_x`: The `x` coordinate of the secp256k1 curve point
/// - `signer_pub_y`: The `y` coordinate of the secp256k1 curve point
/// - `signature`: The signature generated by the signer's key.
fn main(
    message_hash: pub [u8; 32],
    members: pub [Address; 8],
    signer_pub_x: [u8; 32],
    signer_pub_y: [u8; 32],
    signature: [u8; 64],
) {
    assert(verify_signature(signer_pub_x, signer_pub_y, signature, message_hash));

    let signer_address = to_address(signer_pub_x, signer_pub_y);

    assert(members.any(|member| member == signer_address));
}

/// Convert secp256k1 public key to Ethereum address
///
/// ## Value Parameters
///
/// - `pub_x`: X coordinate of a public key
/// - `pub_y`: Y coordinate of a public key
///
/// ## Returns
///
/// - The corresponding Ethereum address
fn to_address(pub_x: [u8; 32], pub_y: [u8; 32]) -> Address {
    let hash = keccak256(concat(pub_x, pub_y), 64);
    let mut out = [0; 20];

    for i in 0..20 {
        out[i] = hash[i + 12];
    }

    out
}

/// Concatenate two byte arrays of 32 bytes into a single 64 byte array
///
/// ## Value Parameters
///
/// - `lhs`: Left-side byte array
/// - `rhs`: Right-side byte array
///
/// ## Returns
///
/// - Concatenation of the `lhs` and `rhs` arrays
fn concat(lhs: [u8; 32], rhs: [u8; 32]) -> [u8; 64] {
    let mut out = [0; 64];

    for i in 0..32 {
        out[i] = lhs[i];
        out[i + 32] = rhs[i];
    }

    out
}
